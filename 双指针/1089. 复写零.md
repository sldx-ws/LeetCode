## 题目描述

> 给你一个长度固定的整数数组 `arr` ，请你将该数组中出现的每个零都复写一遍，并将其余的元素向右平移。
>
> 注意：请不要在超过该数组长度的位置写入元素。请对输入的数组 **就地** 进行上述修改，不要从函数返回任何东西。
>
>  
>
> **示例 1：**
>
> ```
> 输入：arr = [1,0,2,3,0,4,5,0]
> 输出：[1,0,0,2,3,0,0,4]
> 解释：调用函数后，输入的数组将被修改为：[1,0,0,2,3,0,0,4]
> ```
>
> **示例 2：**
>
> ```
> 输入：arr = [1,2,3]
> 输出：[1,2,3]
> 解释：调用函数后，输入的数组将被修改为：[1,2,3]
> ```



## 算法思路

如果「从前向后」进⾏原地复写操作的话，由于`0`的出现会复写两次，导致没有复写的数「被覆
盖掉」。因此我们选择「从后往前」的复写策略。
但是「从后向前」复写的时候，我们需要找到「最后⼀个复写的数」，因此我们的⼤体流程分两
步：
		1、先找到最后⼀个复写的数；
		2、然后从后向前进⾏复写操作  



## C++ 算法代码

```c++
class Solution 
{
public:
    void duplicateZeros(vector<int>& arr) 
    {
        int cur = 0, dst = -1;
        int n = arr.size();

        // 先找到最后一个数
        while (cur < n)
        {
            if (arr[cur] != 0)
                ++dst;
            else
                dst += 2;

            if (dst >= (n - 1))
                break;

            ++cur;
        }

        // 处理边界
        if (dst == n)
        {
            arr[n - 1] = 0;
            --cur;
            dst -= 2;
        }

        // 从后向前完成复写
        while (cur >= 0)
        {
            if (arr[cur] != 0)
            {
                arr[dst] = arr[cur];  
            }
            else
            {
                arr[dst] = 0;
                arr[--dst] = 0;
            }    

            --cur;
            --dst;
        }
    }
};
```

